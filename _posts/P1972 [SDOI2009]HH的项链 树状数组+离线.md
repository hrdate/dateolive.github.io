---
layout:     post                    # 使用的布局（不需要改）
title:      My First problem               # 标题 
subtitle:   Hello World,Hello ACM #副标题
date:       2020-09-12              # 时间
author:     hrdate                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 生活  #123
---

## Hey
>这是我的第一篇题解。

进入你的博客主页，新的文章将会出现在你的主页上.

~~之所以用树状数组+离线，是我因为我写的普通莫队TLE炸裂了~~

## 题目描述

HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。

有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。

## 输入格式

一行一个正整数 n，表示项链长度。
第二行 n 个正整数 $a_i$ ，表示项链中第 i 个贝壳的种类。

第三行一个整数 m，表示 H 询问的个数。
接下来 m 行，每行两个整数 l,r表示询问的区间。

## 输出格式
输出 m 行，每行一个整数，依次表示询问对应的答案。
对于 100% 的数据，$1 ≤n,m,a_i ≤ 10^6,1≤n,m,a_i≤10^6 ，1\le l \le r \le n1≤l≤r≤n。$
本题可能需要较快的读入方式，最大数据点读入数据约 20MB
## 题解
题目求的区间内不同数字的种类个数。
可以先离线m次询问的区间，按照右边界r的大小排序，需注意的标记各个询问的下标，故这m次询问的右边界都符合从左到右即1-n进行遍历；利用树状数组累加的特性，维护每个数组每次出现位置（进行+1和-1操作）即对上次出现的位置-1，对本次出现的位置+1，通过树状数组的range_sum(l,r)求出每次的结果，按照预先处理的下标，存在数组ans[]中。
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h> 
using namespace std;
#define ll long long
#define endl "\n"
const int MAX=1e6+7;
const int mod=1e9+7;
const int inf=0x3f3f3f3f;
struct node{
	int l,r,id;
	bool operator<(const node a)const{
		return r<a.r;
	}
}p[MAX];
int n,m,a[MAX],last[MAX],ans[MAX],tree[MAX];
int lowbit(int x){
	return x&-x; 
}
void add(int n,int x){
	while(n<MAX){
		tree[n]+=x;
		n+=lowbit(n); 
	}
}
int sum(int n){
	int res=0;
	while(n>0){
		res+=tree[n];
		n-=lowbit(n); 
	}
	return res; 
}
int range_sum(int l,int r){
	return sum(r)-sum(l-1);
} 
int main(){
    ios_base::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>m;
	for(int i=1;i<=m;i++)cin>>p[i].l>>p[i].r,p[i].id=i;
	sort(p+1,p+1+m);
	int next=1;
	for(int i=1;i<=m;i++){
		for(int j=next;j<=p[i].r;j++){
			if(last[a[j]]!=0)add(last[a[j]],-1);
			add(j,1);  last[a[j]]=j;
		}
		next=p[i].r+1; ans[p[i].id]=range_sum(p[i].l,p[i].r);
	}
	for(int i=1;i<=m;i++)cout<<ans[i]<<endl;
   return 0;
}  
```
